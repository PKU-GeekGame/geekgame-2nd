阅读题目源码，可知这是一种基于置换的古典密码，并且每加密一个字符，置换矩阵就自乘一次。
对于古典密码，如果得到了密文对应的一部分原文，就能轻易破解出置换矩阵。
第1题的密文大致能看出是一篇文章，而且应该是英文。那么根据英文的特点，单个小写字母构成的单词只有"a"（即使有别的字母独自成词，也不会像"a"一般频繁）。于是乎，先写了个python脚本util1.py，把数字、符号等剔去，每个字母独自成行，但保留空格。处理后得到了letters1.txt，用正则匹配，找到单独的小写字母。假定它们原来都是"a"，再结合行号，计算相同密文之间间隔的公因数，就能计算出轮换的周期，进而构造出一个轮换。但此时这个轮换仍然有很多字母空缺，并且还有一些字母不属于这个轮换。故而需要先随意补全，得到一个临时的置换关系，生成一个错误百出的原文。此时又有更多的单词可以猜测出来，这些原文-密文对可以加入进来，逐渐把整个置换关系补全。整个过程的草稿参见sol1.txt，解密得到的原文参见org1.txt。
第2题乍一看是无意义的字符串，注意到每行字符串的长度一定，并且其中有大量的数字。由于该加密算法并不加密数字，结合题目提示“搜索引擎会给你一些帮助”，搜索某些比较长的数字串，发现：
line 37: 415290769594460w2f485922904s345c
-> 415290769594460e2e485922904f345d
line 145: 9ep4m461268z8034p5a8564q155e67q6
-> 9dd4e461268c8034f5c8564e155c67a6
甚至最后搜索到了以下两个网页：
http://md5.bubble.ro/
https://birdlab.com/md5/list.php
故这些字符串实际上都是MD5，而且绝大多数是1~2个ASCII字符的MD5。那么解密以及还原MD5对应原文也就轻而易举了（实际上不需要解密，只根据数字部分就能查找MD5原文，解密只是我以防万一）。虽然其中有一些不知对应什么原文的MD5，但似乎并不影响最后拼凑出flag。解密过程参见sol2.txt，用查找表生成flag原文参见sol2.py。